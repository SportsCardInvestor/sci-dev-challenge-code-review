-- Query to get prioritized inventory items for processing


-- The SQL contains several critical and high-priority issues that affect both security and performance. Most notably, filtering by total_stock > 0 is applied too late—after LIMIT—which can result in incorrect prioritization and wasted processing. Additionally, the use of scalar subqueries within the SELECT clause, particularly when aggregating related data from other tables, introduces performance bottlenecks and risks for denial-of-service in large datasets. The repeated use of SELECT * across multiple nested subqueries increases the risk of exposing unintended data and reduces maintainability. Deep nesting further complicates readability and optimization, while missing JOIN-based strategies for aggregations leads to inefficiencies. Collectively, these issues make the query error-prone, harder to scale, and potentially insecure..


-- SECURITY: Risk of data overexposure when using SELECT * in large queries. (Medium)
-- PERFORMANCE: Fetching all columns from a nested derived table can lead to unnecessary I/O and memory usage. (Medium)
SELECT *
FROM (
  -- PERFORMANCE: SELECT * in subquery introduces unnecessary complexity and data retrieval. (Medium)
  SELECT *
  FROM (
    -- PERFORMANCE: Deep nesting makes query harder to optimize and maintain. (Low)
    SELECT *
    FROM (
      SELECT
        -- LOGIC: Processing key generated by concatenating attributes. Should ensure uniqueness is guaranteed. (Low)
        -- PERFORMANCE: COUNT(*) used without GROUP BY on full set—acceptable here due to GROUP BY outside. (Low)
        CONCAT_WS('-',
          CASE WHEN COUNT(*) = 1 THEN 'SINGLE' ELSE 'BATCH' END,
          p.category_id,
          p.vendor_id,
          COALESCE(NULLIF(p.size_variant, ''), 'default'),
          COALESCE(NULLIF(p.color_variant, ''), 'standard')
        ) as processing_key,
        -- NO ISSUES: MIN aggregation on timestamp is valid to get earliest sync time.
        MIN(p.last_inventory_check) as last_sync_time,
        -- NO ISSUES: Prioritization level preserved correctly
        MIN(p.priority_slot) as priority_slot,
        -- NO ISSUES: Aggregation to get total inventory stock
        SUM(p.current_stock) as total_stock
      FROM products p
      -- NO ISSUES: Filtering based on priority and active status
      WHERE p.priority_slot = 1
        AND p.status IN ('ACTIVE', 'LOW_STOCK')
        AND p.last_inventory_check IS NOT NULL
      -- NO ISSUES: Proper grouping although we may want to see if there are ways to group more efficiently
      -- SECURITY: GROUP BY on multiple columns is acceptable but ensure all necessary columns are included. (Low)
      -- PERFORMANCE: GROUP BY on multiple columns can lead to performance issues if the dataset is large. (Medium)
      -- FIX: Consider indexing on category_id, vendor_id, size_variant, color_variant for better performance.
      GROUP BY
        p.category_id,
        p.vendor_id,
        p.size_variant,
        p.color_variant
      -- LOGIC: ORDER BY MIN(p.last_inventory_check) is valid but nondeterministic if multiple rows share the same value. (Low)
      -- FIX: Consider adding a secondary sort key to ensure consistent ordering such as p.id or p.created_at.
      ORDER BY
        MIN(p.last_inventory_check) ASC
      -- PERFORMANCE: LIMIT used inside subquery could cause non-representative truncation of dataset. (Medium)
      -- FIX: Ensure that the LIMIT is applied after all necessary filtering and aggregation.
      -- LOGIC: LIMIT 50 may not be sufficient to ensure all high-priority items are captured. (High)
      LIMIT 50
    ) as product_batches

    -- SECURITY: UNION ALL with SELECT * again risks data overexposure. Use explicit column names. (Medium)
    -- PERFORMANCE: UNION ALL can lead to performance issues if the datasets are large. (Medium)
    UNION ALL

    (
      -- SECURITY: SELECT * again risks data overexposure. Use explicit column names. (Medium)
      SELECT *
      FROM (
        SELECT
          -- NO ISSUES: Identifiable key constructed
          CONCAT_WS('-', 'BUNDLE', b.id) as processing_key,
          -- NO ISSUES: Sync timestamp derived from last_updated
          b.last_updated as last_sync_time,
          -- NO ISSUES: Priority level field
          b.priority_level as priority_slot,
          -- PERFORMANCE: Scalar subquery can be expensive on large bundle_items table. (High)
          -- FIX: Replace with LEFT JOIN + GROUP BY for better performance and control.
          (SELECT SUM(bi.quantity) FROM bundle_items bi WHERE bi.bundle_id = b.id) as total_stock
        FROM bundles b
        -- NO ISSUES: Filtering on active status and updated time
        WHERE b.priority_level = 1
          AND b.is_active = 1
          AND b.last_updated IS NOT NULL
        -- NO ISSUES: Sorting by sync time
        ORDER BY
          b.last_updated ASC
        -- LOGIC: LIMIT 50 before applying total_stock > 0 may allow invalid records through. (High)
        LIMIT 50
      ) as bundle_batches
    )

    -- SECURITY: UNION ALL with SELECT * again risks data overexposure. Use explicit column names. (Medium)
    -- PERFORMANCE: UNION ALL can lead to performance issues if the datasets are large. (Medium)
    UNION ALL

    (
      -- SECURITY: SELECT * again is discouraged for performance and exposure reasons. (Medium)
      SELECT *
      FROM (
        SELECT
          -- NO ISSUES: Promo batch key is clearly identifiable
          CONCAT_WS('-', 'PROMO', pm.id) as processing_key,
          -- NO ISSUES: Sync time from last_modified
          pm.last_modified as last_sync_time,
          -- NO ISSUES: Priority rank used correctly
          pm.priority_rank as priority_slot,
          -- PERFORMANCE: Scalar subquery (COUNT) on promo_products is potentially expensive. (Medium)
          -- FIX: Consider JOIN with GROUP BY instead.
          (SELECT COUNT(*) FROM promo_products pp WHERE pp.promo_id = pm.id) as total_stock
        FROM promotions pm
        -- NO ISSUES: Proper date range filtering
        WHERE pm.priority_rank = 1
          AND pm.is_active = 1
          AND pm.start_date <= NOW()
          AND (pm.end_date IS NULL OR pm.end_date >= NOW())
        -- NO ISSUES: Sorting is valid
        ORDER BY
          pm.last_modified ASC
        -- LOGIC: LIMIT before filtering can suppress higher-priority entries with stock. (High)
        LIMIT 50
      ) as promo_batches
    )
  ) as combined_items
  -- NO ISSUES: Final order by unified timestamp
  ORDER BY
    combined_items.last_sync_time ASC
  -- NO ISSUES: Final result capped at 100 entries
  LIMIT 100
) as final_queue
-- LOGIC: Filtering by stock > 0 at the outermost level leads to wasted processing and incorrect prioritization. (Critical)
-- FIX: Apply total_stock > 0 filtering inside each subquery before applying LIMIT
WHERE final_queue.total_stock > 0;